<?php
/*******************************************************************************
  *  [Cacher]
  *  config for class  Cacher
  */

    define('CACHER_PATH_TAGS',     './src/data/tags.php');
    define('CACHER_PATH_SLOTS',    './src/data/slots.php');
    define('CACHER_PATH_BACKENDS', './src/data/backends/');

    # NameSpase prefix for cache key 
    define('CACHER_NAME_SPACE', 'dflt' );

    
    /*
     * Пронстранство имен типов кеширования. Создано в такой упрощенной форме, для экономии системных ресурсов
     * Цель: структуризация типов используемых кешей.
     * Т.е. общий замысел такой: Конкретный слот указывает не на непосредственно конкретный бэкенд, а на константу из пространства имен SlotType
     * исходя только из постановки задачи и области применения. В этом случае изменение стратегии кеширования - это не переписывание каждого слота,
     * а перестройка констант в namespase SlotType
     */

    /**
      * Быстрый но дорогой кеш (в памяти). Низкая надежность.
      * Следует применять для часто запроашиваемых данных с относительно дешевым способом получения, позволяющих дорогое хранилище
      */
    define('CACHER_TYPE_SIMPLEST', 'MemCache' );
    
    /**
      * Быстрый но дорогой кеш (в памяти). Низкая надежность.
      * Следует применять для часто запроашиваемых данных с относительно дешевым способом получения, позволяющих дорогое хранилище
      */
    define('CACHER_TYPE_FAST', 'MemReCache' );

    /**
      * Достаточно быстрое (в основном в памяти), и в тоже время надежное хранилище.
      * Надежностиь достигается за счет каскадности. Т.е. Кеширование происходит на двух уровнях в быстрое (память) и надежное (файлы) хранилища.
      * Поскольку перекешированием занимается только один процесс (за счет блокировок) этот способ не очень сильно нагружает сервер
      * Следует применять для данных, получаемых тяжелым путем (тяжелые запросы и т.п.) и позволяющих использование дорогого хранилища
      */
    define('CACHER_TYPE_SAFE', 'MemReFile' );

    /**
      * Дешевый (в основном на файлах) способ кеширования, но менее производительный по сравнению с self::FAST
      * Следует применять для данных, требующих надежное хранилище
      * или данных, для который использование более быстрых способов в пределах текущей конфигурации сервера непозволительно дорого.
      * (В случае переконфигурирования сервера можно сделать self::CHEAP = self::SAFE)
      */
    define('CACHER_TYPE_CHEAP', 'MemReFile' );

?>
